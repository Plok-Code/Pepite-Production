# -*- coding: utf-8 -*-
"""Codage des fonctions kpi python et generation du kpis.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14uoGT05k-0pXpJ4oz3y9sekfDWJ6hA_A

Géneration du fichier kpis.py pour integrer dans environement de fichoer pour streamlit,
Essai pour le kpi 2 qui sera non traité, mais permet de verifier l'appel des fonctions,
J'ai fais un test en local collab cellule à excecuter dans l'ordre,
le fichoer kpis.py est generer dans le dossier de l'environement actuel du collab sur la gauche et peut etre copier et deplacer par chacun,
l'affichage des dashboard "façon" powerBI" mais avec python se passe mais peux de dynamisme visuel hormis la fenetre contextuelle qui s'affiche quand on parcour les graph avec la souris.
"""

# pour info le  "%%writefile kpis.py"  est là pour générer le  dans l'enviranement virtuel du collap pour pouvoir le copier directement en copier du dossier courrant du collab en cours

# Commented out IPython magic to ensure Python compatibility.
# # @title
# %%writefile kpis.py
# # kpis.py
# # Fichier unique pour l'app Streamlit
# # Chargement d'un seul CSV + reconstruction du schéma en étoile + KPI
# 
# import pandas as pd
# import numpy as np
# import plotly.graph_objects as go
# from plotly.subplots import make_subplots
# import plotly.express as px
# import os
# import gdown
# import re
# 
# #================================================================
# # CHARGEMENT DU FICHIER UNIQUE df_pret_bis.csv
# #================================================================
# 
# def load_main_df():
#     """
#     Télécharge et charge df_pret_bis.csv depuis Google Drive.
#     """
#     file_id = "13KOPghRLPr7BP0ZnM4gSu8p_Doh8HbxN"  # ID extrait de ton lien
#     url = f"https://drive.google.com/uc?id={file_id}"
#     csv_path = "df_pret_bis.csv"
# 
#     if not os.path.exists(csv_path):
#         print("Téléchargement de df_pret_bis.csv depuis Google Drive...")
#         gdown.download(url, csv_path, quiet=False)
# 
#     df = pd.read_csv(csv_path)
#     print(f"df_pret_bis.csv chargé : {df.shape}")
#     return df
# 
# #================================================================
# # VARIABLES GLOBALES
# #================================================================
# 
# DF_PRET_BIS = None
# 
# FACT_MOVIES = None
# DIM_DIRECTOR = None
# DIM_WRITER = None
# BRIDGE_MOVIE_ACTOR = None
# DIM_ACTOR = None
# DIM_GENRE = None
# BRIDGE_GENRE = None
# DIM_CONTENT_RATING = None
# DIM_DATE_YEAR = None
# DIM_COLOR = None
# DIM_KEYWORDS = None
# DIM_COUNTRY_NAME = None
# DIM_LANGUAGE = None
# 
# #================================================================
# # TRANSFORMATION EN SCHÉMA EN ÉTOILE
# #================================================================
# 
# def transform_df_pret_bis_en_etoile(df):
#     df_FACT_MOVIES = df.copy()
# 
#     # Nettoyage movie_title + création movie_title_key par index (ordre alphabétique après tri)
#     df_FACT_MOVIES["movie_title"] = df_FACT_MOVIES["movie_title"].str.strip()
#     df_FACT_MOVIES = df_FACT_MOVIES.sort_values(by=["movie_title"]).reset_index(drop=True)
#     df_FACT_MOVIES["movie_title_key"] = df_FACT_MOVIES.index + 1
# 
#     # DIM_COLOR
#     df_FACT_MOVIES["color_key"] = df_FACT_MOVIES["color"].apply(lambda x: 1 if x == "Color" else 2)
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=['color'])
#     df_DIM_COLOR = pd.DataFrame({"color_key": [1, 2], "color": ["Color", "black and white"]})
# 
#     # DIM_COUNTRY_NAME
#     unique_country = sorted(df_FACT_MOVIES["country_name"].unique())
#     df_DIM_COUNTRY_NAME = pd.DataFrame({"country_name_key": range(1, len(unique_country) + 1), "country_name": unique_country})
#     map_country = dict(zip(unique_country, range(1, len(unique_country) + 1)))
#     df_FACT_MOVIES["country_name_key"] = df_FACT_MOVIES["country_name"].map(map_country)
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["country_name", "country_main"])
# 
#     # DIM_LANGUAGE
#     unique_languages = sorted(df_FACT_MOVIES["language"].unique())
#     df_DIM_LANGUAGE = pd.DataFrame({"language_key": range(1, len(unique_languages) + 1), "language": unique_languages})
#     map_language = dict(zip(unique_languages, range(1, len(unique_languages) + 1)))
#     df_FACT_MOVIES["language_key"] = df_FACT_MOVIES["language"].map(map_language)
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["language"])
# 
#     # DIM_CONTENT_RATING
#     unique_content_rating = sorted(df_FACT_MOVIES["content_rating"].unique())
#     df_DIM_CONTENT_RATING = pd.DataFrame({"content_rating_key": range(1, len(unique_content_rating) + 1), "content_rating": unique_content_rating})
#     map_content_rating = dict(zip(unique_content_rating, range(1, len(unique_content_rating) + 1)))
#     df_FACT_MOVIES["content_rating_key"] = df_FACT_MOVIES["content_rating"].map(map_content_rating)
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["content_rating"])
# 
#     # DIM_DIRECTOR
#     df_DIM_DIRECTOR = df_FACT_MOVIES.groupby("director_name", as_index=False).agg({"director_facebook_likes": "max"})
#     df_DIM_DIRECTOR = df_DIM_DIRECTOR.sort_values("director_name").reset_index(drop=True)
#     df_DIM_DIRECTOR["director_key"] = range(1, len(df_DIM_DIRECTOR) + 1)
#     map_director = dict(zip(df_DIM_DIRECTOR["director_name"], df_DIM_DIRECTOR["director_key"]))
#     df_FACT_MOVIES["director_key"] = df_FACT_MOVIES["director_name"].map(map_director)
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["director_name", "director_facebook_likes"])
# 
#     # DIM_DATE_YEAR
#     df_DIM_DATE_YEAR = df_FACT_MOVIES.groupby("title_year", as_index=False).agg({"decade": "first"})
#     df_DIM_DATE_YEAR = df_DIM_DATE_YEAR.sort_values("title_year").reset_index(drop=True)
#     df_DIM_DATE_YEAR["title_year_key"] = range(1, len(df_DIM_DATE_YEAR) + 1)
#     map_year = dict(zip(df_DIM_DATE_YEAR["title_year"], df_DIM_DATE_YEAR["title_year_key"]))
#     df_FACT_MOVIES["title_year_key"] = df_FACT_MOVIES["title_year"].map(map_year)
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["title_year", "decade"])
# 
#     # DIM_KEYWORDS
#     df_DIM_KEYWORDS = df_FACT_MOVIES[["movie_title_key", "Plot", "plot_keywords_final", "n_plot_kw_final"]].copy()
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["plot_keywords_final", "n_plot_kw_final", "Plot"])
# 
#     # DIM_WRITER
#     df_DIM_WRITER = df_FACT_MOVIES[["movie_title_key", "Writer"]].copy()
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["Writer"])
# 
#     # BRIDGE_GENRE + DIM_GENRE
#     df_BRIDGE_GENRE = df_FACT_MOVIES[["movie_title_key", "genres", "genre_main"]].copy()
#     df_BRIDGE_GENRE["genre_name"] = df_BRIDGE_GENRE["genres"].str.split("|")
#     df_BRIDGE_GENRE = df_BRIDGE_GENRE.explode("genre_name")
#     df_BRIDGE_GENRE["genre_name"] = df_BRIDGE_GENRE["genre_name"].str.strip()
# 
#     liste_genre_name = sorted(list(set(df_BRIDGE_GENRE["genre_name"])))
#     liste_genre_name_keys = range(1, len(liste_genre_name) + 1)
#     dico_map_genre_key = dict(zip(liste_genre_name, liste_genre_name_keys))
# 
#     df_DIM_GENRE = pd.DataFrame({"genre_name": liste_genre_name, "genre_key": liste_genre_name_keys})
# 
#     df_BRIDGE_GENRE["genre_key"] = df_BRIDGE_GENRE["genre_name"].map(dico_map_genre_key)
#     df_BRIDGE_GENRE["genre_is_main"] = (df_BRIDGE_GENRE["genre_name"] == df_BRIDGE_GENRE["genre_main"]).astype(int)
#     df_BRIDGE_GENRE = df_BRIDGE_GENRE[["movie_title_key", "genre_key", "genre_is_main"]].reset_index(drop=True)
# 
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["genres", "genre_main"])
# 
#     # BRIDGE_MOVIE_ACTOR + DIM_ACTOR
#     df_actor_1 = df_FACT_MOVIES[["movie_title_key", "actor_1_name", "actor_1_facebook_likes"]].rename(columns={"actor_1_name": "actor_name", "actor_1_facebook_likes": "actor_facebook_likes"})
#     df_actor_1["actor_position"] = 1
# 
#     df_actor_2 = df_FACT_MOVIES[["movie_title_key", "actor_2_name", "actor_2_facebook_likes"]].rename(columns={"actor_2_name": "actor_name", "actor_2_facebook_likes": "actor_facebook_likes"})
#     df_actor_2["actor_position"] = 2
# 
#     df_actor_3 = df_FACT_MOVIES[["movie_title_key", "actor_3_name", "actor_3_facebook_likes"]].rename(columns={"actor_3_name": "actor_name", "actor_3_facebook_likes": "actor_facebook_likes"})
#     df_actor_3["actor_position"] = 3
# 
#     df_actor_long = pd.concat([df_actor_1, df_actor_2, df_actor_3], ignore_index=True)
#     df_actor_long = df_actor_long.dropna(subset=["actor_name"])
#     df_actor_long["actor_name"] = df_actor_long["actor_name"].str.strip()
# 
#     df_DIM_ACTOR = df_actor_long.groupby("actor_name", as_index=False).agg({"actor_facebook_likes": "max"})
#     df_DIM_ACTOR["actor_key"] = range(1, len(df_DIM_ACTOR) + 1)
# 
#     df_BRIDGE_MOVIE_ACTOR = df_actor_long.merge(df_DIM_ACTOR[["actor_name", "actor_key"]], on="actor_name", how="left")
#     df_BRIDGE_MOVIE_ACTOR = df_BRIDGE_MOVIE_ACTOR[["movie_title_key", "actor_key", "actor_position"]].drop_duplicates()
#     df_BRIDGE_MOVIE_ACTOR = df_BRIDGE_MOVIE_ACTOR.sort_values(by=["movie_title_key", "actor_position"]).reset_index(drop=True)
# 
#     df_DIM_ACTOR = df_DIM_ACTOR[["actor_key", "actor_name", "actor_facebook_likes"]]
# 
#     df_FACT_MOVIES = df_FACT_MOVIES.drop(columns=["actor_1_name", "actor_2_name", "actor_3_name", "actor_1_facebook_likes", "actor_2_facebook_likes", "actor_3_facebook_likes"])
#     df_FACT_MOVIES["movie_title"] = df_FACT_MOVIES["movie_title"].str.strip()
# 
#     # Réorganisation finale des colonnes FACT_MOVIES
#     df_FACT_MOVIES = df_FACT_MOVIES[[
#         'movie_title', 'movie_title_key', 'duration', 'budget', 'Poster', 'budget_is_imputed',
#         'cast_total_facebook_likes', 'facenumber_in_poster', 'gross', 'has_awards',
#         'movie_facebook_likes', 'movie_imdb_link', 'num_critic_for_reviews', 'num_user_for_reviews',
#         'num_voted_users', 'popularity', 'score_global', 'vote_average', 'vote_count',
#         'imdb_id', 'imdb_key', 'imdb_score', 'title_year_key', 'language_key', 'color_key',
#         'content_rating_key', 'country_name_key', 'director_key'
#     ]]
# 
#     df_FACT_MOVIES = df_FACT_MOVIES.sort_values("movie_title_key").reset_index(drop=True)
# 
#     # Retour sous forme de dictionnaire (plus pratique)
#     return {
#         "FACT_MOVIES": df_FACT_MOVIES,
#         "DIM_DIRECTOR": df_DIM_DIRECTOR,
#         "DIM_WRITER": df_DIM_WRITER,
#         "BRIDGE_MOVIE_ACTOR": df_BRIDGE_MOVIE_ACTOR,
#         "DIM_ACTOR": df_DIM_ACTOR,
#         "DIM_GENRE": df_DIM_GENRE,
#         "BRIDGE_GENRE": df_BRIDGE_GENRE,
#         "DIM_CONTENT_RATING": df_DIM_CONTENT_RATING,
#         "DIM_DATE_YEAR": df_DIM_DATE_YEAR,
#         "DIM_COLOR": df_DIM_COLOR,
#         "DIM_KEYWORDS": df_DIM_KEYWORDS,
#         "DIM_COUNTRY_NAME": df_DIM_COUNTRY_NAME,
#         "DIM_LANGUAGE": df_DIM_LANGUAGE
#     }
# 
# def init_data():
#     """
#     Charge le fichier unique et reconstruit le schéma en étoile.
#     """
#     global DF_PRET_BIS
#     global FACT_MOVIES, DIM_DIRECTOR, DIM_WRITER, BRIDGE_MOVIE_ACTOR
#     global DIM_ACTOR, DIM_GENRE, BRIDGE_GENRE, DIM_CONTENT_RATING
#     global DIM_DATE_YEAR, DIM_COLOR, DIM_KEYWORDS, DIM_COUNTRY_NAME, DIM_LANGUAGE
# 
#     DF_PRET_BIS = load_main_df()
# 
#     tables = transform_df_pret_bis_en_etoile(DF_PRET_BIS)
# 
#     FACT_MOVIES = tables["FACT_MOVIES"]
#     DIM_DIRECTOR = tables["DIM_DIRECTOR"]
#     DIM_WRITER = tables["DIM_WRITER"]
#     BRIDGE_MOVIE_ACTOR = tables["BRIDGE_MOVIE_ACTOR"]
#     DIM_ACTOR = tables["DIM_ACTOR"]
#     DIM_GENRE = tables["DIM_GENRE"]
#     BRIDGE_GENRE = tables["BRIDGE_GENRE"]
#     DIM_CONTENT_RATING = tables["DIM_CONTENT_RATING"]
#     DIM_DATE_YEAR = tables["DIM_DATE_YEAR"]
#     DIM_COLOR = tables["DIM_COLOR"]
#     DIM_KEYWORDS = tables["DIM_KEYWORDS"]
#     DIM_COUNTRY_NAME = tables["DIM_COUNTRY_NAME"]
#     DIM_LANGUAGE = tables["DIM_LANGUAGE"]
# 
#     print("Schéma en étoile reconstruit avec succès à partir de df_pret_bis.csv")
# 
# #================================================================
# # FONCTIONS KPI_1
# #================================================================
# 
# 
# def kpi_1():
#     from plotly.subplots import make_subplots
#     import plotly.graph_objects as go
# 
#     # Préparation des données
#     df_director_stats = (
#         FACT_MOVIES.merge(DIM_DIRECTOR, on='director_key', how='left')
#         .query("director_name != 'Unknown'")
#         .groupby(['director_key', 'director_name', 'director_facebook_likes'], as_index=False)
#         .agg(
#             nb_films=('movie_title_key', 'count'),
#             avg_score=('score_global', 'mean'),
#             total_fb_likes=('director_facebook_likes', 'first')
#         )
#     )
# 
#     df_director_stats['single_film'] = df_director_stats['nb_films'] == 1
#     df_director_stats['avg_fb_likes'] = (df_director_stats['total_fb_likes'] / df_director_stats['nb_films']).round(0)
# 
#     # Sélection top
#     df_multi = df_director_stats[df_director_stats['nb_films'] >= 2].sort_values('avg_score', ascending=False).head(10)
#     df_fb_top = df_director_stats.sort_values('total_fb_likes', ascending=False).head(10)
# 
#     # KPI Cards : sans "Total Films"
#     kpi_names = ['Total Réalisateurs', 'Score Moyen', '1 film', '≥ 2 films']
#     kpi_values = [
#         len(df_director_stats),
#         df_director_stats['avg_score'].mean().round(2),
#         df_director_stats['single_film'].sum(),
#         len(df_director_stats) - df_director_stats['single_film'].sum()
#     ]
# 
#     # Table Top 15
#     df_director_kpi = FACT_MOVIES.merge(DIM_DIRECTOR, on='director_key', how='left').query("director_name != 'Unknown'")
# 
#     df_director_stats_table = df_director_kpi.groupby('director_name').agg(
#         nb_films=('movie_title', 'count'),
#         avg_score=('score_global', 'mean'),
#         total_fb_likes=('director_facebook_likes', 'first')
#     ).reset_index()
# 
#     top_15_table = df_director_stats_table.sort_values('nb_films', ascending=False).head(15)
# 
#     # Construction de la grille avec meilleur équilibrage
#     fig = make_subplots(
#         rows=2,
#         cols=2,
#         specs=[[{"type": "bar"}, {"type": "bar"}],
#               [{"type": "bar"}, {"type": "table"}]],
#         subplot_titles=[
#             "Résumé KPI Cards",
#             "Réalisateur  (Nb Film >= 2)",
#             "Top 10 FB Likes",
#             "Top 15 réalisateurs - Nb de films"
#         ],
#         column_widths=[0.5, 0.5],
#         row_heights=[0.50, 0.50],           # proportion ligne de graph 1 et 2
#         vertical_spacing=0.15,              # Espacement vertical augmenté pour éviter chevauchement
#         horizontal_spacing=0.10
#     )
# 
#     # KPI Cards
#     fig.add_trace(go.Bar(
#         x=kpi_names,
#         y=kpi_values,
#         text=kpi_values,
#         textposition="outside",
#         marker_color=['#FFB020', '#2BD576', '#FFB020', '#2BD576', '#FFB020'],
#         name='KPI',
#         hovertemplate="%{x}: %{y}"
#     ), row=1, col=1)
# 
#     # Graph multi
#     fig.add_trace(go.Bar(
#         x=df_multi['director_name'],
#         y=df_multi['avg_score'].round(2),
#         text=df_multi['avg_score'].round(2),
#         textposition="outside",
#         marker_color='#FFB020',
#         name='2 films ou plus',
#         opacity=1,
#         hovertemplate=(
#             "Réalisateur: %{x}<br>"
#             "Nb films: %{customdata[0]}<br>"
#             "Score moyen: %{y:.2f}<br>"
#             "Total FB Likes: %{customdata[1]}<br>"
#             "Moyenne FB Likes/film: %{customdata[2]}"
#         ),
#         customdata=df_multi[['nb_films', 'total_fb_likes', 'avg_fb_likes']].values
#     ), row=1, col=2)
# 
#     # Graph Top 10 FB Likes - vertical
#     fig.add_trace(go.Bar(
#         x=df_fb_top['director_name'],
#         y=df_fb_top['total_fb_likes'],
#         text=df_fb_top['total_fb_likes'],
#         textposition="outside",
#         marker_color='#FFB020',
#         name='Top FB Likes',
#         opacity=1,
#         hovertemplate=(
#             "Réalisateur: %{x}<br>"
#             "Nb films: %{customdata[0]}<br>"
#             "Total FB Likes: %{y}<br>"
#             "Moyenne FB Likes/film: %{customdata[1]}"
#         ),
#         customdata=df_fb_top[['nb_films', 'avg_fb_likes']].values
#     ), row=2, col=1)
# 
#     # Table Top 15
#     fig.add_trace(go.Table(
#         columnwidth=[45, 20, 15, 20],
#         header=dict(
#             values=["<b>Réalisateur</b>", "<b>Total FB Likes</b>", "<b>Nb films</b>", "<b>Score moyen</b>"],
#             fill_color="#141C2B",
#             font=dict(color="#EAF0FF", size=14),
#             align="left"
#         ),
#         cells=dict(
#             values=[
#                 top_15_table['director_name'],
#                 top_15_table['nb_films'],
#                 top_15_table['total_fb_likes'].map("{:,}".format),
#                 top_15_table['avg_score'].round(2)
#             ],
#             fill_color="#0B0F17",
#             font=dict(color="#EAF0FF", size=13),
#             align="left",
#             height=28
#         )
#     ), row=2, col=2)
# 
#     # STYLE GLOBAL - Harmonisation WildFlix
#     fig.update_layout(
#         height=900,
#         paper_bgcolor="#0B0F17",
#         plot_bgcolor="#141C2B",
#         font=dict(family="Inter", color="#EAF0FF"),
#         title=dict(
#             text="KPI 1 – Réalisateurs : Score de filmographie disponible et Facebook Likes",
#             x=0.5,
#             font=dict(size=26)
#         ),
#         showlegend=False,
#         margin=dict(t=120, l=100, r=100, b=100)
#     )
# 
#     fig.update_annotations(
#         font=dict(family="Inter", size=18, color="#EAF0FF")
#     )
# 
#     fig.update_xaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     fig.update_yaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
#     # precisions y par subplot
# 
#     fig.update_yaxes(title_text="Valeurs", automargin=True, range=[0, 2600], row=1, col=1)
#     fig.update_yaxes(title_text="Score moyen (films)", automargin=True, range=[7.8, 8.5], row=1, col=2)
#     fig.update_yaxes(title_text="Total FB Likes", automargin=True, range=[10000, 25000], row=2, col=1)
# 
#     # fig.update_xaxes(title_text="Réalisateur", tickangle=45, row=2, col=1)
#     return fig
# 
# #================================================================
# # FONCTIONS KPI_2
# #================================================================
# 
# def kpi_2():
#     # KPI 2 – POPULARITÉ DES WRITERS
#     import pandas as pd
#     import numpy as np
#     import plotly.graph_objects as go
#     from plotly.subplots import make_subplots
#     import re
# 
#     # 1. DF KPI COMPLET (unknown inclus)
# 
#     df_writers_tmp = FACT_MOVIES.merge(
#         DIM_WRITER,
#         on="movie_title_key",
#         how="left").copy()
# 
#     def split_writers(writer):
#         if pd.isna(writer):
#             return []
#         return [w.strip() for w in re.split(r",| et ", writer) if w.strip()]
# 
#     df_writers_tmp["writer_name"] = df_writers_tmp["Writer"].apply(split_writers)
#     df_writers_tmp = df_writers_tmp.explode("writer_name")
# 
#     # 2. CALCUL KPI WRITERS (GLOBAL)
# 
#     writer_stats = (
#         df_writers_tmp
#         .groupby("writer_name")
#         .agg(
#             nb_films=("movie_title_key", "count"),
#             score_moyen=("score_global", "mean"),
#             fb_likes_total=("movie_facebook_likes", "sum"),
#             popularite_moyenne=("popularity", "mean"))
#         .reset_index())
# 
#     # 3. DF D'AFFICHAGE (unknown EXCLU)
# 
#     writer_stats_display = writer_stats[
#         (writer_stats["writer_name"] != "unknown")]
# 
#     writer_stats_display_valid = writer_stats_display[
#         writer_stats_display["nb_films"] >= 2]
# 
#     # KPI références
#     top_score_writer = writer_stats_display_valid.sort_values(
#         "score_moyen", ascending=False).iloc[0]
# 
#     score_moyen_global = writer_stats_display_valid["score_moyen"].mean()
#     delta_score = top_score_writer["score_moyen"] - score_moyen_global
# 
#     # Top datasets
#     top_score_df = writer_stats_display_valid.sort_values(
#         "score_moyen", ascending=False).head(10)
# 
#     top_pop_df = writer_stats_display.sort_values(
#         "fb_likes_total", ascending=False).head(10)
# 
#     impact_df = writer_stats_display_valid.sort_values(
#         "nb_films", ascending=False).head(15)
# 
#     # 4. DASHBOARD 2x2
# 
#     fig = make_subplots(
#         rows=2,
#         cols=2,
#         specs=[
#             [{"type": "indicator"}, {"type": "bar"}],
#             [{"type": "bar"}, {"type": "scatter"}]],
#         subplot_titles=(
#             "KPI – Writer Référence",
#             "Top 10 – Score Moyen",
#             "Top 10 – Popularité Facebook",
#             "Impact : Volume vs Qualité"))
# 
#     # KPI CARD
#     fig.add_trace(
#         go.Indicator(
#             mode="number+delta",
#             value=top_score_writer["score_moyen"],
#             number={
#                 "font": {"size": 46, "color": "#FFB020"},
#                 "suffix": " pts"},
#             delta={
#                 "reference": score_moyen_global,
#                 "valueformat": ".2f",
#                 "increasing": {"color": "#2BD576"},
#                 "decreasing": {"color": "#FF3B3B"},
#                 "suffix": " vs moy"},
#             title={"text": (
#                     "<span style='font-size:14px;color:#A7B3CC'>Writer référence</span>"
#                     "<br><br>"
#                     f"<span style='font-size:22px;font-weight:600'>{top_score_writer['writer_name']}</span>"
#                     "<br><span style='font-size:12px;color:#A7B3CC'>Note globale</span>")}),
#         row=1, col=1)
# 
#     # BAR VERTICALE : SCORE MOYEN
#     fig.add_trace(
#         go.Bar(
#             x=top_score_df["writer_name"],
#             y=top_score_df["score_moyen"],
#             marker_color="#FFB020",
#             text=top_score_df["score_moyen"].round(2),
#             textposition="outside"),
#         row=1, col=2)
# 
#     # BAR : POPULARITÉ FB
#     fig.add_trace(
#         go.Bar(
#             x=top_pop_df["fb_likes_total"],
#             y=top_pop_df["writer_name"],
#             orientation="h",
#             marker_color="#FFB020",
#             text=top_pop_df["fb_likes_total"],
#             textposition="outside"),
#         row=2, col=1)
# 
#     # SCATTER : IMPACT
#     fig.add_trace(
#         go.Scatter(
#             x=impact_df["nb_films"],
#             y=impact_df["score_moyen"],
#             mode="markers+text",
#             text=impact_df["writer_name"],
#             textposition="top center",
#             marker=dict(
#                 size=impact_df["popularite_moyenne"] * 2,
#                 color="#FFB020",
#                 opacity=1)),
#         row=2, col=2)
# 
#     # 5. STYLE GLOBAL
# 
#     fig.update_layout(
#         height=900,
#         paper_bgcolor="#0B0F17",
#         plot_bgcolor="#141C2B",
#         font=dict(
#             family="Inter",
#             color="#EAF0FF"),
#         title=dict(
#             text="KPI 2 – Popularité & Impact des Writers",
#             x=0.5,
#             font=dict(size=28)),
#         showlegend=False,
#         margin=dict(t=90, l=60, r=60, b=60))
# 
#     fig.update_xaxes(color="#CBD5E1", gridcolor="#25324A")
#     fig.update_yaxes(color="#CBD5E1", gridcolor="#25324A")
# 
#     # Échelle X fixe à 25 sur le scatter
#     fig.update_xaxes(
#         title="Nombre de films",
#         range=[10, 25],
#         row=2, col=2)
# 
#     fig.update_yaxes(
#         title="Score moyen",
#         row=2, col=2)
#     fig.update_yaxes(
#         range=[7.5 , 9],
#         row=1, col=2)
#     # Rotation des labels X pour le bar vertical (lisibilité noms longs)
#     fig.update_xaxes(
#         tickangle=45,
#         row=1, col=2)
# 
#     return fig
# 
# #================================================================
# # FONCTIONS KPI_3
# #================================================================
# 
# def kpi_3():
#     # KPI 3 – POPULARITÉ DES ACTEURS (version finale avec table triée par nb_films)
# 
#     import pandas as pd
#     import numpy as np
#     import plotly.graph_objects as go
#     from plotly.subplots import make_subplots
# 
#     # 1. DF KPI COMPLET (actors)
#     df_actors_tmp = (
#         FACT_MOVIES
#         .merge(BRIDGE_MOVIE_ACTOR, on="movie_title_key", how="left")
#         .merge(DIM_ACTOR, on="actor_key", how="left")
#         .copy()
#     )
# 
#     # 2. CALCUL KPI ACTEURS (GLOBAL)
#     actor_stats = (
#         df_actors_tmp
#         .query("actor_name != 'Unknow'")
#         .groupby("actor_name")
#         .agg(
#             nb_films=("movie_title_key", "count"),
#             score_moyen=("score_global", "mean"),
#             fb_likes_total=("actor_facebook_likes", "sum"),
#             fb_likes_moyen=("actor_facebook_likes", "mean")
#         )
#         .reset_index()
#     )
# 
#     # 3. DF D'AFFICHAGE
# 
#     actor_stats = actor_stats[
#         actor_stats["nb_films"] >= 3
#     ]
# 
#     # 4. KPI RÉFÉRENCES
#     top_fb_actor = actor_stats.sort_values("fb_likes_total", ascending=False).iloc[0]
# 
#     top_20_fb = actor_stats.sort_values("fb_likes_total", ascending=False).head(20)
#     moyenne_top_20_likes = top_20_fb["fb_likes_total"].mean()
# 
#     # 5. DATASETS VISU
#     top_score_df = actor_stats.sort_values("score_moyen", ascending=False).head(10)
# 
#     top_pop_df = actor_stats.sort_values("fb_likes_total", ascending=False).head(10)
# 
#     # Table Top 15 acteurs triée par nombre de films décroissant (exclu unknown)
#     top_15_table = (
#         actor_stats
#         .query("actor_name != 'Unknown'")
#         .sort_values("nb_films", ascending=False)
#         .head(15)
#     )
# 
#     # 6. DASHBOARD 2x2 (table à la place du scatter)
#     fig = make_subplots(
#         rows=2,
#         cols=2,
#         specs=[
#             [{"type": "indicator"}, {"type": "bar"}],
#             [{"type": "bar"}, {"type": "table"}]
#         ],
#         subplot_titles=(
#             "KPI  Acteur le plus suivi sur Facebook",
#             "Top 10  Score moyen des films",
#             "Top 10  Popularité Facebook totale",
#             "Top 15 acteurs (triés par nb de films)"
#         ),
#     vertical_spacing = 0.18
#     )
# 
#     # KPI CARD
#     fig.add_trace(
#         go.Indicator(
#             mode="number+delta",
#             value=top_fb_actor["fb_likes_total"],
#             number={
#                 "font": {"size": 46, "color": "#FFB020"},
#                 "valueformat": ",",
#                 "suffix": " likes"
#             },
#             delta={
#                 "reference": moyenne_top_20_likes,
#                 "valueformat": ",.0f",
#                 "suffix": " vs moy Top 20",
#                 "increasing": {"color": "#2BD576"},
#                 "decreasing": {"color": "#FF3B3B"}
#             },
#             title={
#                 "text": (
#                     "<span style='font-size:14px;color:#A7B3CC'>Acteur n°1 Facebook</span>"
#                     "<br><br>"
#                     f"<span style='font-size:22px;font-weight:600'>{top_fb_actor['actor_name']}</span>"
#                     "<br><span style='font-size:12px;color:#A7B3CC'>Diff. avec moy Top 20</span>"
#                 )
#             }
#         ),
#         row=1, col=1
#     )
# 
#     # BAR VERTICALE : SCORE MOYEN
#     fig.add_trace(
#         go.Bar(
#             x=top_score_df["actor_name"],
#             y=top_score_df["score_moyen"],
#             marker_color="#FFB020",
#             text=top_score_df["score_moyen"].round(2),
#             textposition="outside",
#             hovertemplate=(
#                 "<b>%{x}</b><br>"
#                 "Score moyen : %{y:.2f}<br>"
#                 "Nb films : %{customdata}<extra></extra>"
#             ),
#             customdata=top_score_df["nb_films"]
#         ),
#         row=1, col=2
#     )
# 
#     # BAR HORIZONTALE : POPULARITÉ FB
#     fig.add_trace(
#         go.Bar(
#             x=top_pop_df["actor_name"],
#             y=top_pop_df["fb_likes_total"],
#             marker_color="#FFB020",
#             text=top_pop_df["fb_likes_total"].apply(
#                 lambda x: f"{x/1_000_000:.1f}M" if x >= 1_000_000 else f"{x/1_000:.0f}K"
#             ),
#             textposition="outside",
#             hovertemplate=(
#                 "<b>%{x}</b><br>"
#                 "Likes Facebook : %{y:,.0f}<br>"
#                 "Nb films : %{customdata}<extra></extra>"
#             ),
#             customdata=top_pop_df["nb_films"]
#         ),
#         row=2, col=1
#     )
#     # TABLE TOP 15 ACTEURS - TRIÉE PAR NB FILMS
#     fig.add_trace(
#         go.Table(
#             columnwidth=[40, 20, 15, 20],
#             header=dict(
#                 values=["<b>Acteur</b>", "<b>Total FB Likes</b>", "<b>Nb films</b>", "<b>Score moyen</b>"],
#                 fill_color="#141C2B",
#                 font=dict(color="#EAF0FF", size=14),
#                 align="left"
#             ),
#             cells=dict(
#                 values=[
#                     top_15_table["actor_name"],
#                     top_15_table["fb_likes_total"].map("{:,}".format),
#                     top_15_table["nb_films"],
#                     top_15_table["score_moyen"].round(2)
#                 ],
#                 fill_color="#0B0F17",
#                 font=dict(color="#EAF0FF", size=13),
#                 align="left",
#                 height=30
#             )
#         ),
#         row=2, col=2
#     )
# 
#     # STYLE GLOBAL - Harmonisation WildFlix
#     fig.update_layout(
#         height=900,
#         paper_bgcolor="#0B0F17",
#         plot_bgcolor="#141C2B",
#         font=dict(family="Inter", color="#EAF0FF"),
#         title=dict(
#             text="KPI 3 – Popularité & Impact des Acteurs",
#             x=0.5,
#             font=dict(size=26)
#         ),
#         showlegend=False,
#         margin=dict(t=100, l=80, r=80, b=80)
#     )
# 
#     fig.update_annotations(
#         font=dict(family="Inter", size=18, color="#EAF0FF")
#     )
# 
#     fig.update_xaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     fig.update_yaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     # Titres d'axes spécifiques
#     fig.update_yaxes(title_text="Score moyen (films)", range=[7, 8.8], row=1, col=2)
#     fig.update_xaxes(tickangle=45, row=1, col=2)
#     return fig
# 
# #================================================================
# # FONCTIONS KPI_4
# #================================================================
# 
# def kpi_4():
#     # KPI 4 – POPULARITÉ DES FILMS PAR GENRE ET ANNÉE DE SORTIE
# 
#     import pandas as pd
#     import numpy as np
#     import plotly.graph_objects as go
#     from plotly.subplots import make_subplots
# 
#     # 1. PRÉPARATION DES DONNÉES
# 
#     df_genre_tmp = (
#         FACT_MOVIES
#         .merge(BRIDGE_GENRE, on="movie_title_key", how="left")
#         .merge(DIM_GENRE, on="genre_key", how="left")
#         .merge(DIM_DATE_YEAR, on="title_year_key", how="left")
#         .copy())
# 
#     df_genre_tmp["decile_score"] = pd.qcut(
#         df_genre_tmp["score_global"],
#         q=10,
#         labels=False,
#         duplicates="drop") + 1
# 
#     df_genre_tmp["categorie"] = np.select(
#         [df_genre_tmp["decile_score"] <= 3,
#         (df_genre_tmp["decile_score"] >= 4) & (df_genre_tmp["decile_score"] <= 5),
#         df_genre_tmp["decile_score"] >= 6],
#         ["Exclu", "Pépite", "Blockbuster"],
#         default="Exclu")
# 
#     df_analysis = df_genre_tmp[
#         df_genre_tmp["categorie"] != "Exclu"].copy()
# 
#     total_films_tous = FACT_MOVIES["movie_title_key"].nunique()
#     total_films_analyse = df_analysis["movie_title_key"].nunique()
# 
#     genre_decade_stats = (
#         df_analysis
#         .groupby(["decade", "genre_name", "categorie"])
#         .agg(
#             nb_films=("movie_title_key", "nunique"),
#             score_moyen=("score_global", "mean"),
#             popularity_moyenne=("popularity", "mean"))
#         .reset_index())
# 
#     pivot_blockbuster = genre_decade_stats[
#         genre_decade_stats["categorie"] == "Blockbuster"].pivot_table(index="genre_name",
#                     columns="decade",
#                     values="nb_films",
#                     fill_value=0)
# 
#     pivot_pepite = genre_decade_stats[
#         genre_decade_stats["categorie"] == "Pépite"].pivot_table(index="genre_name",
#                     columns="decade",
#                     values="nb_films",
#                     fill_value=0)
# 
#     top_genre_per_decade = (genre_decade_stats
#         .groupby(["decade", "genre_name"])
#         .agg(nb_films_total=("nb_films", "sum"))
#         .reset_index()
#         .sort_values(["decade", "nb_films_total"], ascending=[True, False])
#         .groupby("decade")
#         .head(5))
# 
#     genre_le_plus_frequent = (genre_decade_stats
#         .groupby("genre_name")["nb_films"]
#         .sum()
#         .idxmax())
# 
#     # 2. DASHBOARD 2x2
# 
#     fig = make_subplots(
#         rows=2,
#         cols=2,
#         specs=[[{"type": "indicator"}, {"type": "heatmap"}],
#               [{"type": "bar"}, {"type": "heatmap"}]],
#         subplot_titles=(
#             "KPI – Focus Pépites & Blockbusters",
#             "Blockbusters : Nb films par genre & décennie",
#             "Top 5 genres par décennie (pépite + blockbuster)",
#             "Pépites : Nb films par genre & décennie"
#         ),
#     vertical_spacing = 0.18
#     )
# 
#     # KPI CARD
#     fig.add_trace(
#         go.Indicator(
#             mode="number",
#             value=total_films_analyse,
#             number={
#                 "font": {"size": 46, "color": "#FFB020"},
#                 "suffix": " films"
#             },
#             title={
#                 "text": (
#                     "<span style='font-size:14px;color:#A7B3CC'>Analyse sur pépites + blockbusters uniquement<br>"
#                     f"(déciles 4 à 10 du score_global / total {total_films_tous} films)</span>"
#                     "<br><br>"
#                     f"<span style='font-size:22px;font-weight:600'>{genre_le_plus_frequent}</span>"
#                     "<br><span style='font-size:12px;color:#A7B3CC'>Genre le plus fréquent dans cette sélection</span>"
#                 )
#             }
#         ),
#         row=1, col=1
#     )
# 
#     # HEATMAP BLOCKBUSTERS
#     fig.add_trace(
#         go.Heatmap(
#             z=pivot_blockbuster.values,
#             x=pivot_blockbuster.columns,
#             y=pivot_blockbuster.index,
#             colorscale=[[0, "#0B0F17"], [1, "#FFB020"]],
#             text=pivot_blockbuster.values,
#             texttemplate="%{text}",
#             textfont={"size": 12},
#             hovertemplate="Décennie: %{x}<br>Genre: %{y}<br>Nb blockbusters: %{z}<extra></extra>",
#             colorbar=dict(
#                 title="Nb films",
#                 titleside="right",
#                 thickness=15,
#                 len=0.45,
#                 y=0.77,
#                 yanchor="middle"
#             ),
#             name="Blockbusters"
#         ),
#         row=1, col=2
#     )
# 
#     # BAR TOP 5
#     fig.add_trace(
#         go.Bar(
#             x=top_genre_per_decade["decade"].astype(str) + " - " + top_genre_per_decade["genre_name"],
#             y=top_genre_per_decade["nb_films_total"],
#             marker_color="#FFB020",
#             text=top_genre_per_decade["nb_films_total"],
#             textposition="outside",
#             hovertemplate="<b>%{x}</b><br>Nb films: %{y}<extra></extra>"
#         ),
#         row=2, col=1
#     )
# 
#     # HEATMAP PÉPITES
#     fig.add_trace(
#         go.Heatmap(
#             z=pivot_pepite.values,
#             x=pivot_pepite.columns,
#             y=pivot_pepite.index,
#             colorscale=[[0, "#0B0F17"], [1, "#FFB020"]],
#             text=pivot_pepite.values,
#             texttemplate="%{text}",
#             textfont={"size": 12},
#             hovertemplate="Décennie: %{x}<br>Genre: %{y}<br>Nb pépites: %{z}<extra></extra>",
#             colorbar=dict(
#                 title="Nb films",
#                 titleside="right",
#                 thickness=15,
#                 len=0.45,
#                 y=0.23,
#                 yanchor="middle"
#             ),
#             name="Pépites"
#         ),
#         row=2, col=2
#     )
# 
#     # 3. STYLE GLOBAL - Harmonisation WildFlix
# 
#     fig.update_layout(
#         height=900,
#         paper_bgcolor="#0B0F17",
#         plot_bgcolor="#141C2B",
#         font=dict(family="Inter", color="#EAF0FF"),
#         title=dict(
#             text="KPI 4 – Popularité des films par Genre & Décennie",
#             x=0.5,
#             font=dict(size=26)
#         ),
#         showlegend=False,
#         margin=dict(t=100, l=80, r=80, b=80)
#     )
# 
#     # Taille et style des titres des subplots
#     fig.update_annotations(
#         font=dict(family="Inter", size=18, color="#EAF0FF")
#     )
# 
#     # Style des axes (titres et ticks)
#     fig.update_xaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     fig.update_yaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     # Titres d'axes spécifiques à ce KPI
#     fig.update_xaxes(title_text="Décennie", row=1, col=2)
#     fig.update_yaxes(title_text="Genre", row=1, col=2)
# 
#     fig.update_xaxes(title_text="Décennie - Genre", tickangle=45, row=2, col=1)
#     fig.update_yaxes(title_text="Nombre de films", row=2, col=1)
# 
#     fig.update_xaxes(title_text="Décennie", row=2, col=2)
#     fig.update_yaxes(title_text="Genre", row=2, col=2)
# 
#     # Décalage étiquettes Y pour les heatmaps
#     fig.update_yaxes(ticklabelposition="outside left", row=1, col=2)
#     fig.update_yaxes(ticklabelposition="outside left", row=2, col=2)
#     return fig
# 
# #================================================================
# # FONCTIONS KPI_5
# #================================================================
# 
# def kpi_5():
#     # KPI 5 – MEILLEURS FILMS PAR DURÉE
# 
#     import pandas as pd
#     import numpy as np
#     import plotly.graph_objects as go
#     from plotly.subplots import make_subplots
# 
#     # 1. PRÉPARATION DES DONNÉES
# 
#     df_duration = FACT_MOVIES.copy()
# 
#     df_duration["decile_score"] = pd.qcut(
#         df_duration["score_global"],
#         q=10,
#         labels=False,
#         duplicates="drop") + 1
# 
#     df_duration["categorie"] = np.select(
#         [df_duration["decile_score"] <= 3,
#         (df_duration["decile_score"] >= 4) & (df_duration["decile_score"] <= 5),
#         df_duration["decile_score"] >= 6],
#         ["Exclu", "Pépite", "Blockbuster"],
#         default="Exclu")
# 
#     bins = [-np.inf, 59, 89, 119, np.inf]
#     labels = ["< 1h", "1h - 1h29", "1h30 - 1h59", "2h et +"]
#     df_duration["duree_cat"] = pd.cut(
#         df_duration["duration"],
#         bins=bins,
#         labels=labels)
# 
#     df_analysis = df_duration[
#         df_duration["categorie"] != "Exclu"].copy()
# 
#     df_genre_main = BRIDGE_GENRE[BRIDGE_GENRE["genre_is_main"] == 1][["movie_title_key", "genre_key"]]
#     df_with_genre = df_analysis.merge(df_genre_main, on="movie_title_key", how="left")
#     df_with_genre = df_with_genre.merge(DIM_GENRE, on="genre_key", how="left")
# 
#     nb_films_analyse = df_analysis["movie_title_key"].nunique()
#     nb_blockbusters = len(df_analysis[df_analysis["categorie"] == "Blockbuster"])
#     nb_pepites = len(df_analysis[df_analysis["categorie"] == "Pépite"])
# 
#     # Meilleurs films par catégorie de durée (top 1 score_global) - pour les 4 cards en haut
#     top_by_duration = (
#         df_analysis
#         .sort_values("score_global", ascending=False)
#         .groupby("duree_cat", observed=False)
#         .first()
#         .reset_index()
#     )
# 
#     # TABLE ALTERNÉE : 15 meilleurs Blockbuster + 15 meilleures Pépites, alternés
#     top_15_blockbuster = df_analysis[df_analysis["categorie"] == "Blockbuster"] \
#         .sort_values("score_global", ascending=False).head(15)
# 
#     top_15_pepite = df_analysis[df_analysis["categorie"] == "Pépite"] \
#         .sort_values("score_global", ascending=False).head(15)
# 
#     # Alternance : Blockbuster 1, Pépite 1, Blockbuster 2, Pépite 2...
#     table_empilee = pd.concat([
#         top_15_blockbuster.assign(rank=range(1, 16)),
#         top_15_pepite.assign(rank=range(1, 16))
#     ]).sort_values("rank").drop(columns="rank")
# 
#     table_empilee["Type"] = table_empilee["categorie"].map({"Blockbuster": "Blockbuster", "Pépite": "Pépite"})
#     table_empilee = table_empilee[["Type", "duree_cat", "movie_title", "duration", "score_global"]].reset_index(drop=True)
# 
#     # Répartition pour le bar
#     repartition = df_analysis.groupby("duree_cat", observed=False).size()
# 
#     # 2. DASHBOARD : 4 KPI Cards en haut + Table alternée + Bar en bas
# 
#     fig = make_subplots(
#         rows=2,
#         cols=4,
#         specs=[
#             [{"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}],
#             [{"type": "table", "colspan": 2}, None, {"type": "bar", "colspan": 2}, None]
#         ],
#         subplot_titles=(
#             "< 1h", "1h - 1h29", "1h30 - 1h59", "2h et +",
#             "Top 30 alternés (Blockbuster / Pépite)", "Nb de film par durée", "Répartition des films analysés par durée", ""
#         ),
#         row_heights=[0.5, 0.5],
#     vertical_spacing = 0.01
#     )
# 
#     # 4 KPI Cards : meilleur film par catégorie de durée
#     for i, row in top_by_duration.iterrows():
#         col = i + 1
#         fig.add_trace(
#             go.Indicator(
#                 mode="number",
#                 value=row["score_global"],
#                 number={
#                     "font": {"size": 40, "color": "#FFB020"},
#                     "suffix": " pts"
#                 },
#                 title={
#                     "text": (
#                         f"<span style='font-size:18px;font-weight:600'>{row['movie_title']}</span>"
#                         f"<br><span style='font-size:12px;color:#A7B3CC'>"
#                         f"{int(row['duration'])} min"
#                         f"</span>"
#                     ),
#                     "align": "center"
#                 }
#             ),
#             row=1, col=col
#         )
# 
#     # TABLE ALTERNÉE DÉROULANTE (30 lignes, row 2 col 1-2)
#     fig.add_trace(
#         go.Table(
#             columnwidth=[10, 25, 40, 15, 15],
#             header=dict(
#                 values=["Type", "Catégorie durée", "Film", "Durée (min)", "Score"],
#                 fill_color="#141C2B",
#                 font=dict(color="#EAF0FF", size=14),
#                 align="left"
#             ),
#             cells=dict(
#                 values=[
#                     table_empilee["Type"],
#                     table_empilee["duree_cat"],
#                     table_empilee["movie_title"],
#                     table_empilee["duration"].astype(int),
#                     table_empilee["score_global"].round(2)
#                 ],
#                 fill_color="#0B0F17",
#                 font=dict(color="#EAF0FF", size=13),
#                 align="left",
#                 height=28  # Hauteur réduite pour afficher plus de lignes
#             )
#         ),
#         row=2, col=1
#     )
# 
#     # BAR RÉPARTITION (row 2 col 3-4)
#     fig.add_trace(
#         go.Bar(
#             x=repartition.index,
#             y=repartition.values,
#             marker_color="#FFB020",
#             text=repartition.values,
#             textposition="outside",
#             hovertemplate="<b>%{x}</b><br>Nb films: %{y}<extra></extra>"
#         ),
#         row=2, col=3
#     )
# 
#     # 3. STYLE GLOBAL - Harmonisation WildFlix
# 
#     fig.update_layout(
#         height=800,
#         paper_bgcolor="#0B0F17",
#         plot_bgcolor="#141C2B",
#         font=dict(family="Inter", color="#EAF0FF"),
#         title=dict(
#             text="KPI 5 – Meilleurs films selon leur durée",
#             x=0.5,
#             font=dict(size=26)
#         ),
#         showlegend=False,
#         margin=dict(t=100, l=80, r=80, b=80)
#     )
# 
#     # Taille et style des titres des subplots
#     fig.update_annotations(
#         font=dict(family="Inter", size=18, color="#EAF0FF")
#     )
# 
#     # Style des axes
#     fig.update_xaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     fig.update_yaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     # Titres d'axes spécifiques
#     fig.update_yaxes(range= [0 , 2200], row=2, col=3)
#     return fig
# 
# #================================================================
# # FONCTIONS KPI_6
# #================================================================
# 
# def kpi_6():
#     # KPI 6 – MEILLEURS FILMS PAR CLASSIFICATION ÂGE (Content Rating)
# 
#     import pandas as pd
#     import numpy as np
#     import plotly.graph_objects as go
#     from plotly.subplots import make_subplots
# 
#     # 1. PRÉPARATION DES DONNÉES
#     FACT_MOVIES['movie_title'] = FACT_MOVIES['movie_title'].astype(str).str.strip()
#     DIM_DIRECTOR['director_name'] = DIM_DIRECTOR['director_name'].astype(str).str.strip()
#     df_rating = FACT_MOVIES.copy()
# 
#     # Jointure content_rating
#     df_rating = df_rating.merge(DIM_CONTENT_RATING, on="content_rating_key", how="left")
# 
#     # Déciles score_global
#     df_rating["decile_score"] = pd.qcut(
#         df_rating["score_global"],
#         q=10,
#         labels=False,
#         duplicates="drop") + 1
# 
#     # Catégories
#     df_rating["categorie"] = np.select(
#         [df_rating["decile_score"] <= 3,
#         (df_rating["decile_score"] >= 4) & (df_rating["decile_score"] <= 5),
#         df_rating["decile_score"] >= 6],
#         ["Exclu", "Pépite", "Blockbuster"],
#         default="Exclu")
# 
#     # Filtre : uniquement pépites + blockbusters
#     df_analysis = df_rating[
#         df_rating["categorie"] != "Exclu"].copy()
# 
#     # Stats globales
#     nb_films_analyse = df_analysis["movie_title_key"].nunique()
#     nb_blockbusters = len(df_analysis[df_analysis["categorie"] == "Blockbuster"])
#     nb_pepites = len(df_analysis[df_analysis["categorie"] == "Pépite"])
# 
#     # Répartition par content_rating
#     repartition_rating = df_analysis.groupby("content_rating", observed=False).size()
# 
#     # Top 3 Blockbuster par content_rating
#     top3_blockbuster = (
#         df_analysis[df_analysis["categorie"] == "Blockbuster"]
#         .sort_values(["content_rating", "score_global"], ascending=[True, False])
#         .groupby("content_rating", observed=False)
#         .head(3)
#         .sort_values(["content_rating", "score_global"], ascending=[True, False]))
# 
#     # Top 3 Pépite par content_rating
#     top3_pepite = (
#         df_analysis[df_analysis["categorie"] == "Pépite"]
#         .sort_values(["content_rating", "score_global"], ascending=[True, False])
#         .groupby("content_rating", observed=False)
#         .head(3)
#         .sort_values(["content_rating", "score_global"], ascending=[True, False]))
# 
#     # Meilleur film Unrated (parmi pépites + blockbusters)
#     best_unrated = df_analysis[
#         df_analysis["content_rating"] == "Unrated"].sort_values("score_global", ascending=False).iloc[0]
# 
#     # Score moyen par content_rating
#     score_moyen_par_rating = (
#         df_analysis.groupby("content_rating", observed=False)["score_global"].mean().round(2))
# 
#     # PRÉPARATION DE LA TABLE : Top films (Blockbuster + Pépite) triés par score global
#     top_films_table = pd.concat([
#         top3_blockbuster[['movie_title', 'score_global', 'content_rating']],
#         top3_pepite[['movie_title', 'score_global', 'content_rating']]
#     ]).sort_values("score_global", ascending=False).reset_index(drop=True)
# 
#     # 2. DASHBOARD 2x2
#     fig = make_subplots(
#         rows=2,
#         cols=2,
#         specs=[
#             [{"type": "indicator"}, {"type": "bar"}],
#             [{"type": "bar"}, {"type": "table"}]  # ← Table en row 2 col 2
#         ],
#         subplot_titles=(
#             "KPI – Meilleurs films par classification âge",
#             "Répartition des films analysés par classification",
#             "Score moyen par classification âge",
#             "Top films par score global"
#         ),
#     vertical_spacing = 0.15
#     )
# 
#     # KPI CARD
#     fig.add_trace(
#         go.Indicator(
#             mode="number+delta",
#             value=nb_films_analyse,
#             number={
#                 "font": {"size": 46, "color": "#FFB020"},
#                 "suffix": " films"
#             },
#             title={
#                 "text": (
#                     f"<span style='font-size:14px;color:#A7B3CC'>Pépites + Blockbusters analysés<br>"
#                     f"({nb_blockbusters} blockbusters | {nb_pepites} pépites)</span>"
#                     f"<br><br>"
#                     f"<span style='font-size:18px;font-weight:600'>{best_unrated['movie_title']}</span>"
#                     f"<br><span style='font-size:12px;color:#A7B3CC'>"
#                     f"Meilleur film Unrated (Score {best_unrated['score_global']:.2f})"
#                     f"</span>"
#                 )
#             }
#         ),
#         row=1, col=1
#     )
# 
#     # BAR : RÉPARTITION PAR CLASSIFICATION
#     fig.add_trace(
#         go.Bar(
#             x=repartition_rating.index,
#             y=repartition_rating.values,
#             marker_color="#FFB020",
#             text=repartition_rating.values,
#             textposition="outside",
#             hovertemplate="<b>%{x}</b><br>Nb films: %{y}<extra></extra>"
#         ),
#         row=1, col=2
#     )
# 
#     # BAR : SCORE MOYEN PAR CLASSIFICATION
#     fig.add_trace(
#         go.Bar(
#             x=score_moyen_par_rating.index,
#             y=score_moyen_par_rating.values,
#             marker_color="#FFB020",
#             text=score_moyen_par_rating.values,
#             textposition="outside",
#             hovertemplate="<b>%{x}</b><br>Score moyen: %{y:.2f}<extra></extra>"
#         ),
#         row=2, col=1
#     )
# 
#     # TABLE TOP FILMS (remplace le scatter en row 2 col 2)
#     fig.add_trace(
#         go.Table(
#             columnwidth=[50, 20, 30],
#             header=dict(
#                 values=["<b>Film</b>", "<b>Score global</b>", "<b>Classification</b>"],
#                 fill_color="#141C2B",
#                 font=dict(color="#EAF0FF", size=14),
#                 align="left"
#             ),
#             cells=dict(
#                 values=[
#                     top_films_table["movie_title"],
#                     top_films_table["score_global"].round(2),
#                     top_films_table["content_rating"]
#                 ],
#                 fill_color="#0B0F17",
#                 font=dict(color="#EAF0FF", size=13),
#                 align="left",
#                 height=30
#             )
#         ),
#         row=2, col=2
#     )
# 
#     # 3. STYLE GLOBAL - Harmonisation WildFlix
#     fig.update_layout(
#         height=900,
#         paper_bgcolor="#0B0F17",
#         plot_bgcolor="#141C2B",
#         font=dict(family="Inter", color="#EAF0FF"),
#         title=dict(
#             text="KPI 6 – Meilleurs films par classification âge (Content Rating)",
#             x=0.5,
#             font=dict(size=26)
#         ),
#         showlegend=False,
#         margin=dict(t=100, l=80, r=80, b=80)
#     )
# 
#     # Taille et style des titres des subplots
#     fig.update_annotations(
#         font=dict(family="Inter", size=18, color="#EAF0FF")
#     )
# 
#     # Style des axes
#     fig.update_xaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     fig.update_yaxes(
#         color="#A7B3CC",
#         gridcolor="#25324A",
#         title_font=dict(size=16, family="Inter", color="#A7B3CC"),
#         tickfont=dict(size=14, family="Inter", color="#A7B3CC")
#     )
# 
#     # Titres d'axes spécifiques
#     fig.update_xaxes(title_text="Classification âge", row=1, col=2)
#     fig.update_yaxes(title_text="Nombre de films", row=1, col=2)
# 
#     fig.update_xaxes(title_text="Classification âge", row=2, col=1)
#     fig.update_yaxes(title_text="Score moyen global", range=[6 , 7.4],  row=2, col=1)
#     return fig

from kpis import init_data, kpi_1, kpi_2, kpi_3, kpi_4, kpi_5, kpi_6

init_data()  # charge le CSV + transforme en 13 tables

kpi_1()